# Pipe の基本

図にあるように write と read を別 goroutine で処理させ、バイトデータをバッファなしチャネル(ブロッキングあり)でデータを転送することでファイル転送処理などを効率化できる。

## 通常のファイル転送処理

<img src="./スクリーンショット 2023-12-01 8.08.04.png" />

上図のように通常は同期的にファイルからデータを読み込み、メモリにデータを全て展開してから net.Conn に書き込むという二段構えになる。

## pipe を使った転送処理

<img src="./スクリーンショット 2023-12-01 6.59.50.png" />
一方でPipeを使うと、別々のgoroutineで「ファイルから読み込む処理」と「読み込んだデータをソケットに書き込む処理」をデータが読み込めたチャンクデータごとに同時進行できる。

この事で全てのデータをバッファに展開する事なく同期的に読み込みと転送処理を行う事ができるようになる。

[これがわかりやすい](https://medium.com/eureka-engineering/file-uploads-in-go-with-io-pipe-75519dfa647b)

> Pipe は、メモリ内に同期パイプを作成します。これは io.Reader を必要としているコードと、io.Writer を必要としているコード間を接続します。片方の読み込みは、もう一方の書き込みに対応し、データのコピーは二者間でバッファリングされることなくダイレクトに行われます。

io.Copy: これは基本的にデータをそのままの形で一方から他方へ転送する際に適しています。データに加工や変更が不要で、単に一つのソースから他のデスティネーションへ効率的にデータを移動させたい場合に最適です。例えば、ファイルのコピー、ネットワークストリームの転送などが該当します。

io.Pipe: 一方で、io.Pipe は、データの生成と消費をリアルタイムで行いたい場合、特に途中でデータに何らかの加工や変更を加える必要がある場合に適しています。io.Pipe はリアルタイムのデータストリーム処理において、データの生成者（ライター）と消費者（リーダー）間で直接、同期的なデータの受け渡しを可能にします。これにより、データを生成する側で何かしらの加工を施した後、その結果を即座に別のプロセスが読み取ってさらに処理を行うようなシナリオに適しています。

要するに、単純なデータ転送には io.Copy が、データのリアルタイム処理や途中での加工が必要な場合には io.Pipe が適しているというのが正しい認識です。

# ポイント

データの加工という点がポイントで、加工するというこは io.Writer のインターフェースを使用するということで、この書き込みデータをそのまま Reader として使いたい場合に pipe が役だつ。
